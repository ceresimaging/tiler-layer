# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TilerLayer
                                 A QGIS plugin
 Ceres Tiler Layer Loader
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-05-12
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Ceres Imaging
        email                : mmiranda@ceresimaging.net
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import sys, os
from cmath import log
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import (
    Qgis,
    QgsSettings,
    QgsRasterLayer,
    QgsVectorTileLayer,
    QgsProject,
    QgsMessageLog,
    QgsRectangle,
    QgsCoordinateReferenceSystem,
    QgsCoordinateTransform,
)

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .tiler_layer_dockwidget import TilerLayerDockWidget

from .tiler_layer_options import TilerLayerOptionsFactory

try:
    import worksclient as wc
except ImportError:
    this_dir = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(this_dir, "worksclient-0.0.8-py3-none-any.whl")
    sys.path.append(path)
    import worksclient as wc


class TilerLayer:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "TilerLayer_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr("&Tiler Layer")
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar("TilerLayer")
        self.toolbar.setObjectName("TilerLayer")

        # print "** INITIALIZING TilerLayer"

        self.pluginIsActive = False
        self.dockwidget = None
        self.settings = QgsSettings()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("TilerLayer", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = os.path.join(self.plugin_dir, "icon.png")
        self.add_action(
            icon_path,
            text=self.tr(""),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        self.options_factory = TilerLayerOptionsFactory(self.plugin_dir)
        self.options_factory.setTitle(self.tr("Tiler Layer"))
        self.iface.registerOptionsWidgetFactory(self.options_factory)

    # --------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # print "** CLOSING TilerLayer"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        # print "** UNLOAD TilerLayer"

        for action in self.actions:
            self.iface.removePluginMenu(self.tr("&Tiler Layer"), action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

        self.iface.unregisterOptionsWidgetFactory(self.options_factory)

    # --------------------------------------------------------------------------

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            if (
                self.settings.value("tiler_layer/token")
                and self.settings.value("tiler_layer/api")
                and self.settings.value("tiler_layer/tiler")
            ):
                wc.auth_token = self.settings.value("tiler_layer/token")
                wc.api_base = self.settings.value("tiler_layer/api")
                self.baseUrl = self.settings.value("tiler_layer/tiler")
            else:
                self.iface.messageBar().pushMessage(
                    "Error", f"Some settings are missing", level=Qgis.Critical
                )
                return

            self.pluginIsActive = True

            # print "** STARTING TilerLayer"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget is None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = TilerLayerDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            self.dockwidget.load.clicked.connect(self.loadLayer)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

    # --------------------------------------------------------------------------

    def log(self, message):
        self.iface.messageBar().pushMessage("Info", f"{message}", level=Qgis.Info)

    def loadLayer(self):
        layer = self.dockwidget.layer.currentData()
        if layer == "mosaic":
            self.loadMosaic()
        elif layer == "fieldgeo":
            self.loadFieldGeo()
        elif layer == "imagery":
            self.loadImagery()
        elif layer == "pli":
            self.loadPLI()
        elif layer == "grid":
            self.loadGrid()
        elif layer == "sensor":
            self.loadSensor()
        elif layer == "asset":
            self.loadAsset()

    def loadRaster(self, url, title, field=None):
        xyz = "%7Bz%7D/%7Bx%7D/%7By%7D"
        format = "png"
        maxZoom = 18
        minZoom = 0
        crs = "EPSG3857"

        url = f"type=xyz&url={self.baseUrl}/{url}/{xyz}.{format}&zmax={maxZoom}&zmin={minZoom}&crs={crs}"

        layer = QgsRasterLayer(url, title, "wms")

        if layer.isValid():
            QgsProject.instance().addMapLayer(layer)
            if field and self.dockwidget.extent.isChecked():
                layer.setExtent(self.fieldExtent(field, 100))
        else:
            self.iface.messageBar().pushMessage(
                "Error", f"Invalid Raster Layer: {url}", level=Qgis.Critical
            )

        return layer

    def loadVector(self, url, title, field=None):
        xyz = "%7Bz%7D/%7Bx%7D/%7By%7D"
        format = "mvt"
        maxZoom = 18
        minZoom = 0
        crs = "EPSG3857"

        url = f"type=xyz&url={self.baseUrl}/{url}/{xyz}.{format}&zmax={maxZoom}&zmin={minZoom}&crs={crs}"

        layer = QgsVectorTileLayer(url, title)

        if layer.isValid():
            if field and self.dockwidget.extent.isChecked():
                layer.setExtent(self.fieldExtent(field))
            QgsProject.instance().addMapLayer(layer)
            self.iface.zoomToActiveLayer()
        else:
            self.iface.messageBar().pushMessage(
                "Error", f"Invalid Vector Layer: {url}", level=Qgis.Critical
            )

        return layer

    def loadStyle(self, layer, style):
        layer.loadNamedStyle(os.path.join(self.plugin_dir, "styles", f"{style}.qml"))

    def fieldExtent(self, field, buffer=10):
        coords = field["boundary"]
        zoomRectangle = QgsRectangle(coords[0], coords[1], coords[2], coords[3])
        transform = QgsCoordinateTransform(
            QgsCoordinateReferenceSystem("EPSG:4326"),
            QgsCoordinateReferenceSystem(
                self.iface.mapCanvas().mapSettings().destinationCrs().authid()
            ),
            QgsProject.instance(),
        )
        return transform.transformBoundingBox(zoomRectangle).buffered(buffer)

    def loadMosaic(self):
        flight = self.dockwidget.flight.text()
        field = self.dockwidget.field.text()
        type = self.dockwidget.mosaicType.currentText()
        url = f"mosaic/{flight}/{field}/{type}"
        field = wc.Field.retrieve(field)
        title = f"Mosaic - {flight} - {field['name']} - {type}"
        self.loadRaster(url, title, field)

    def loadImagery(self):
        overlay = self.dockwidget.overlay.text()
        url = f"imagery/{overlay}"
        overlay = wc.Overlay.retrieve(overlay)
        field = wc.Field.retrieve(overlay["field_id"])
        title = f"Imagery - {field['name']} - {overlay['overlay_type']}"
        self.loadRaster(url, title, field)

    def loadFieldGeo(self):
        field = self.dockwidget.field.text()
        url = f"fieldgeo"
        title = f"FieldGeo"
        if field != "":
            url = f"{url}/field/{field}"
            field = wc.Field.retrieve(field)
            title = f"{title} - {field['name']}"
        self.loadVector(url, title, field)

    def loadPLI(self):
        overlay = self.dockwidget.overlay.text()
        url = f"tree/data/{overlay}"
        overlay = wc.Overlay.retrieve(overlay)
        field = wc.Field.retrieve(overlay["field_id"])
        title = f"PLI - {field['name']} - {overlay['overlay_type']}"
        layer = self.loadVector(url, title, field)
        self.loadStyle(layer, "pli")
        layer.triggerRepaint()

    def loadGrid(self):
        overlay = self.dockwidget.overlay.text()
        grid = self.dockwidget.grid.text()
        url = f"grid/{overlay}/{grid}"
        overlay = wc.Overlay.retrieve(overlay)
        field = wc.Field.retrieve(overlay["field_id"])
        title = f"Grid - {field['name']} - {overlay['overlay_type']}"
        layer = self.loadVector(url, title, field)
        self.loadStyle(layer, "grid")
        layer.triggerRepaint()

    def loadSensor(self):
        customer = self.dockwidget.customer.text()
        url = f"sensor/{customer}"
        customer = wc.Customer.retrieve(customer)
        title = f"Sensor {customer['name']}"
        self.loadVector(url, title)

    def loadAsset(self):
        asset = self.dockwidget.asset.text()
        url = f"asset/{asset}"
        asset = wc.Satellite.get_asset(asset)
        field = wc.Field.retrieve(asset["field"])
        title = f"Asset - {asset['id']} - {asset['asset_type']}"
        self.loadRaster(url, title, field)
